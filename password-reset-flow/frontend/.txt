frontend  : 

app.jsx : 
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { useState, useEffect } from 'react';
import Navbar from './components/Navbar';
import Login from './components/Login';
import Signup from './components/Signup';
import ResetPassword from './components/ResetPassword';
import UpdatePassword from './components/UpdatePassword';
import ProtectedPage from './components/ProtectedPage';

function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  // Check authentication on initial render
  useEffect(() => {
    const token = localStorage.getItem('token');
    setIsAuthenticated(!!token);
  }, []);

  const handleLogout = () => {
    localStorage.removeItem('token');
    setIsAuthenticated(false); // Update state after logout
    Navigate('/login')
  };

  return (
    <Router>
      <Navbar isAuthenticated={isAuthenticated} onLogout={handleLogout} />
      <Routes>
        {/* If authenticated, redirect to /protected; otherwise, go to login */}
        <Route path="/" element={isAuthenticated ? <Navigate to="/protected" /> : <Navigate to="/login" />} />
        <Route path="/login" element={isAuthenticated ? <Navigate to="/protected" /> : <Login setIsAuthenticated={setIsAuthenticated} />} />
        <Route path="/signup" element={<Signup />} />
        <Route path="/reset-password" element={<ResetPassword />} />
        <Route path="/update-password/:token" element={<UpdatePassword />} />
        {/* Protected route */}
        <Route path="/protected" element={isAuthenticated ? <ProtectedPage /> : <Navigate to="/login" />} />
      </Routes>
    </Router>
  );
}

export default App;

vite.config.js : 
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true, // ensures the host header of the request matches the backend
        secure: false, // only necessary if your backend is using HTTPS with self-signed certificates
      },
    },
  },
});

login.jsx : 

import React, { useState } from 'react';
import axios from 'axios';
import { Link, useNavigate } from 'react-router-dom';
import { TextField, Button, Container, Typography, Box, Alert, Grid } from '@mui/material';

const Login = ({ setIsAuthenticated }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(''); // Clear errors before submission
    try {
      const res = await axios.post(`/api/authentication`, { email, password });
      localStorage.setItem('token', res.data.token);
      localStorage.setItem('email', email); // Store email

      // Reset form fields after successful login
      setEmail('');
      setPassword('');
      setError('');

      // Update authentication status in App component
      setIsAuthenticated(true);

      // Navigate to the protected route
      navigate('/protected');
    } catch (err) {
      console.error(err.response);

      // Reset password on error, keep email for convenience
      setPassword('');
      setError(err.response?.data?.message || 'Invalid login credentials');
    }
  };

  return (
    <Container maxWidth="sm" sx={{ mt: 4 }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography variant="h4" gutterBottom>
          Login
        </Typography>
        {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
        <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%' }}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="Email"
                variant="outlined"
                fullWidth
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                label="Password"
                type="password"
                variant="outlined"
                fullWidth
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </Grid>
          </Grid>
          <Button
            type="submit"
            variant="contained"
            color="primary"
            fullWidth
            sx={{ mt: 2 }}
          >
            Login
          </Button>
          <Typography sx={{ mt: 2 }}>
            Don't have an account? <Link to="/signup">Sign up here</Link>
          </Typography>
        </Box>
      </Box>
    </Container>
  );
};

export default Login;


navbar.jsx : 

import React from 'react';
import { Link } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button } from '@mui/material';

const Navbar = ({ isAuthenticated, onLogout }) => {
  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          Authentication System
        </Typography>

        {/* Conditional rendering based on authentication status */}
        {!isAuthenticated ? (
          <>
            <Button color="inherit" component={Link} to="/login">
              Login
            </Button>
            <Button color="inherit" component={Link} to="/signup">
              Signup
            </Button>
          </>
        ) : (
          <>
            <Button color="inherit" component={Link} to="/reset-password">
              Reset Password
            </Button>
            <Button color="inherit" component={Link} to="/update-password/:token">
              Update Password
            </Button>
            <Button color="inherit" onClick={onLogout}>
              Logout
            </Button>
          </>
        )}
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;

protectedpage.jsx : 

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

const ProtectedPage = () => {
  const [message, setMessage] = useState('');
  const navigate = useNavigate();

  useEffect(() => {
    const token = localStorage.getItem('token');
  
    if (!token) {
      navigate('/login');
    } else {
      axios.get(`/api/data`, {
        headers: { Authorization: `Bearer ${token}` },
      })
      .then(response => {
        setMessage(response.data.message);
      })
      .catch(err => {
        localStorage.removeItem('token');
        navigate('/login');
      });
    }
  }, [navigate]);
  
  return (
    <div className="container">
      <h2>Protected Page</h2>
      {message ? <p>{message}</p> : <p>Loading...</p>}
    </div>
  );
};

export default ProtectedPage;

ResetPassword.jsx : 

import React, { useState } from 'react';
import axios from 'axios';

const ResetPassword = () => {
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const res = await axios.post(`/api/reset-password`, { email });
      setMessage(res.data.message);
    } catch (err) {
      setMessage('Error sending reset email');
    }
  };

  return (
    <div className="container">
      <h2>Reset Password</h2>
      {message && <p>{message}</p>}
      <form onSubmit={handleSubmit}>
        <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Enter your email" required />
        <button type="submit" className="btn btn-primary">Send Reset Email</button>
      </form>
    </div>
  );
};

export default ResetPassword;


signup.jsx : 

import React, { useState } from 'react';
import axios from 'axios';
import { TextField, Button, Container, Typography, Box, Alert } from '@mui/material';

const Signup = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const res = await axios.post(`/api/user`, { email, password });
      setMessage(res.data.message);
      setError('');
    } catch (err) {
      setError('Error during signup');
      setMessage('');
    }
  };

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 4 }}>
        <Typography variant="h4" gutterBottom>
          Signup
        </Typography>
        {message && <Alert severity="success">{message}</Alert>}
        {error && <Alert severity="error">{error}</Alert>}
        <form onSubmit={handleSubmit}>
          <TextField
            label="Email"
            variant="outlined"
            fullWidth
            margin="normal"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
          <TextField
            label="Password"
            type="password"
            variant="outlined"
            fullWidth
            margin="normal"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
          <Button type="submit" variant="contained" color="primary" fullWidth>
            Signup
          </Button>
        </form>
      </Box>
    </Container>
  );
};

export default Signup;


UpdatePassword.jsx : 

import React, { useState } from 'react';
import { useParams } from 'react-router-dom';
import axios from 'axios';

const UpdatePassword = () => {
  const { token } = useParams(); // Extract the token from URL
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    try {
      // Send POST request to backend to update the password
      const res = await axios.post(`/api/reset-password/${token}`, { password });
      setMessage(res.data.message); // Show success message
      setError('');
    } catch (err) {
      setError('Error resetting password. Please try again.'); // Show error message
      setMessage('');
    }
  };

  return (
    <div className="container">
      <h2>Update Password</h2>
      {message && <p style={{ color: 'green' }}>{message}</p>}
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <input 
            type="password" 
            value={password} 
            onChange={(e) => setPassword(e.target.value)} 
            placeholder="New Password" 
            required 
            className="form-control"
          />
        </div>
        <div className="form-group">
          <input 
            type="password" 
            value={confirmPassword} 
            onChange={(e) => setConfirmPassword(e.target.value)} 
            placeholder="Confirm New Password" 
            required 
            className="form-control"
          />
        </div>
        <button type="submit" className="btn btn-primary">Update Password</button>
      </form>
    </div>
  );
};

export default UpdatePassword;

backend : 
middleware : 
verifyToken.js : 
const jwt = require("jsonwebtoken");
const User = require("../model/User");

const verifyToken = async (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ message: "Missing Token" });
  }

  const token = authHeader.split(" ")[1];

  try {
    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const user = await User.findById(decoded.id);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    req.user = user;
    next();
  } catch (err) {
    return res.status(403).json({ message: "Invalid Token" });
  }
};

module.exports = verifyToken;

model : 
user.js : 
const mongoose = require("mongoose");

const UserSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
  },
  password: {
    type: String,
    required: true,
  },
  resetPasswordToken: String,
  resetPasswordExpires: Date,
});

module.exports = mongoose.model("User", UserSchema);

routes : 
userRoutes.js : 
const express = require("express");
const bcrypt = require("bcryptjs");
const router = express.Router();
const User = require("../model/User");
const { generateToken } = require("../utils/tokenUtils");
const verifyToken = require("../middleware/verifyToken");
const { sendPasswordResetEmail } = require("../utils/emailUtils");

router.get("/test", (req, res) => res.json({ message: "API Testing successful" }));

// Register user
router.post("/register", async (req, res) => {
  const { email, password } = req.body;

  try {
    const userExists = await User.findOne({ email });

    if (userExists) {
      return res.status(400).json({ message: "User already exists" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ email, password: hashedPassword });

    await newUser.save();
    return res.status(201).json({ message: "User created successfully" });
  } catch (err) {
    return res.status(500).json({ message: "Server error" });
  }
});

// User authentication
router.post("/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const isMatch = await bcrypt.compare(password, user.password);

    if (!isMatch) {
      return res.status(401).json({ message: "Incorrect password" });
    }

    const token = generateToken(user);
    return res.status(200).json({ token });
  } catch (err) {
    return res.status(500).json({ message: "Server error" });
  }
});

// Protected route example
router.get("/data", verifyToken, (req, res) => {
  res.json({ message: `Welcome, ${req.user.email}! This is protected data.` });
});

// Request password reset
router.post("/reset-password", async (req, res) => {
  const { email } = req.body;

  try {
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const token = Math.random().toString(36).slice(-8);
    user.resetPasswordToken = token;
    user.resetPasswordExpires = Date.now() + 3600000; // 1 hour

    await user.save();
    await sendPasswordResetEmail(user.email, token);

    return res.status(200).json({ message: "Password reset email sent" });
  } catch (err) {
    return res.status(500).json({ message: "Error sending email" });
  }
});

// Reset password with token
router.post("/reset-password/:token", async (req, res) => {
  const { token } = req.params;
  const { password } = req.body;

  if (!password || password.length < 8) {
    return res.status(400).json({ message: "Password must be at least 8 characters long" });
  }

  try {
    const user = await User.findOne({
      resetPasswordToken: token.toLowerCase(),
      resetPasswordExpires: { $gt: Date.now() },
    });

    if (!user) {
      return res.status(400).json({ message: "Invalid or expired token" });
    }

    user.password = await bcrypt.hash(password, 10);
    user.resetPasswordToken = null;
    user.resetPasswordExpires = null;

    await user.save();
    return res.status(200).json({ message: "Password updated successfully" });
  } catch (err) {
    return res.status(500).json({ message: "Server error" });
  }
});

module.exports = router;

utils : 
emailUtils : 
const nodemailer = require("nodemailer");

const sendPasswordResetEmail = async (email, token) => {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USERNAME,
      pass: process.env.EMAIL_PASSWORD,
    },
  });

  const message = {
    from: process.env.EMAIL_USERNAME,
    to: email,
    subject: "Password Reset Request",
    text: `Please use the following token to reset your password: ${token}`,
  };

  return transporter.sendMail(message);
};

module.exports = { sendPasswordResetEmail };

tokenUtils : 
const jwt = require("jsonwebtoken");

const generateToken = (user) => {
  return jwt.sign({ id: user._id }, process.env.SECRET_KEY, { expiresIn: "1h" });
};

module.exports = { generateToken };


index.js : 
require("dotenv").config();
const express = require("express");
const mongoose = require("mongoose");
const userRoutes = require("./routes/userRoutes");

const cors = require("cors");

const app = express();

app.use(cors());
app.use(express.json());

// Routes
app.use("/api", userRoutes);


// Connect to MongoDB
mongoose
  .connect(process.env.DB_CONNECTION_STRING, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => console.log("Database connected"))
  .catch((err) => console.log("Database connection error:", err));

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server started on port ${PORT}`);
});

.env : 
DB_CONNECTION_STRING = mongodb+srv://lovelypraveendp:1JpTNvxIIV95OJwD@user.vy9qb.mongodb.net/password-reset-flow
SECRET_KEY = SPIDERMAN
PORT = 3000
EMAIL_USERNAME = lovelypraveendp@gmail.com
EMAIL_PASSWORD = icoe ncxe nwey dxkp


map the front end with the backend without changing any functionalities because i cant able to fetch the details from the backend to the frontend 